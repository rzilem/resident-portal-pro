
import { jsPDF } from 'jspdf';
import 'jspdf-autotable';

// Extend the jsPDF type to include autoTable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => jsPDF;
  }
}

export interface PdfOptions {
  title?: string;
  filename?: string;
  author?: string;
  subject?: string;
  keywords?: string;
  creator?: string;
  orientation?: 'portrait' | 'landscape';
  unit?: 'pt' | 'mm' | 'cm' | 'in';
  format?: 'a4' | 'letter' | 'legal' | [number, number];
  compress?: boolean;
  footer?: {
    text: string;
    fontSize?: number;
    color?: string;
  };
}

export class PDFGeneratorCore {
  protected doc: jsPDF;
  protected options: Required<PdfOptions>;
  protected currentY: number = 20;
  protected pageWidth: number;
  protected pageHeight: number;
  protected marginLeft: number = 20;
  protected marginRight: number = 20;
  protected lineHeight: number = 12;

  constructor(options: PdfOptions = {}) {
    const defaultOptions: Required<PdfOptions> = {
      title: 'Generated Document',
      filename: 'document.pdf',
      author: 'HOA Management System',
      subject: 'Document',
      keywords: 'pdf, document',
      creator: 'HOA Management System',
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4',
      compress: true,
      footer: {
        text: 'Generated by HOA Management System',
        fontSize: 8,
        color: '#666666'
      }
    };

    this.options = { ...defaultOptions, ...options };
    this.doc = new jsPDF({
      orientation: this.options.orientation,
      unit: this.options.unit,
      format: this.options.format,
      compress: this.options.compress
    });
    
    // Set document metadata
    this.doc.setProperties({
      title: this.options.title,
      subject: this.options.subject,
      author: this.options.author,
      keywords: this.options.keywords,
      creator: this.options.creator
    });
    
    this.pageWidth = this.doc.internal.pageSize.getWidth();
    this.pageHeight = this.doc.internal.pageSize.getHeight();
    
    // Add footer
    this.addFooter();
  }
  
  private addFooter() {
    const { text, fontSize = 8, color = '#666666' } = this.options.footer;
    
    const addFooterToPages = () => {
      const pageCount = this.doc.getNumberOfPages();
      
      for (let i = 1; i <= pageCount; i++) {
        this.doc.setPage(i);
        this.doc.setFontSize(fontSize);
        this.doc.setTextColor(color);
        this.doc.text(
          text,
          this.pageWidth / 2,
          this.pageHeight - 10,
          { align: 'center' }
        );
        this.doc.text(
          `Page ${i} of ${pageCount}`,
          this.pageWidth - this.marginRight,
          this.pageHeight - 10,
          { align: 'right' }
        );
      }
    };
    
    // Set up event handler for adding footer when document is complete
    this.doc.internal.events.subscribe('addPage', function() {
      addFooterToPages();
    });
    
    // Add footer to the first page
    addFooterToPages();
  }
  
  addTitle(text: string, fontSize: number = 18) {
    this.doc.setFontSize(fontSize);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text(text, this.pageWidth / 2, this.currentY, { align: 'center' });
    this.currentY += this.lineHeight;
    return this;
  }
  
  addSubtitle(text: string, fontSize: number = 14) {
    this.doc.setFontSize(fontSize);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text(text, this.marginLeft, this.currentY);
    this.currentY += this.lineHeight;
    return this;
  }
  
  addText(text: string, fontSize: number = 10) {
    this.doc.setFontSize(fontSize);
    this.doc.setFont('helvetica', 'normal');
    this.doc.text(text, this.marginLeft, this.currentY);
    this.currentY += this.lineHeight;
    return this;
  }
  
  addLineBreak(count: number = 1) {
    this.currentY += this.lineHeight * count;
    return this;
  }
  
  addHorizontalLine() {
    this.doc.line(
      this.marginLeft,
      this.currentY,
      this.pageWidth - this.marginRight,
      this.currentY
    );
    this.currentY += this.lineHeight / 2;
    return this;
  }
  
  addTable(headers: string[], data: any[][]) {
    this.doc.autoTable({
      startY: this.currentY,
      head: [headers],
      body: data,
      margin: { left: this.marginLeft, right: this.marginRight },
      styles: { overflow: 'linebreak' },
      headStyles: { fillColor: [66, 66, 66] }
    });
    
    this.currentY = (this.doc as any).lastAutoTable.finalY + 10;
    return this;
  }
  
  addLogo(imgData: string, x?: number, y?: number, width?: number, height?: number) {
    const _x = x || this.marginLeft;
    const _y = y || this.currentY;
    const _width = width || 40;
    const _height = height || 20;
    
    this.doc.addImage(imgData, 'PNG', _x, _y, _width, _height);
    this.currentY += _height + this.lineHeight;
    return this;
  }
  
  addSignatureField(label: string, x?: number, y?: number) {
    const _x = x || this.marginLeft;
    const _y = y || this.currentY;
    
    this.doc.setFontSize(10);
    this.doc.text(label, _x, _y);
    this.doc.line(_x, _y + 5, _x + 60, _y + 5);
    this.doc.text('Date: _____________', _x + 80, _y);
    
    this.currentY = _y + this.lineHeight * 2;
    return this;
  }
  
  save() {
    this.doc.save(this.options.filename);
    return this;
  }
  
  getBlob(): Blob {
    return this.doc.output('blob');
  }
  
  getBase64(): string {
    return this.doc.output('datauristring');
  }
  
  getPdfUrl(): string {
    const blob = this.getBlob();
    return URL.createObjectURL(blob);
  }
}
